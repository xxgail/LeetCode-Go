package main

import (
	"fmt"
	"github.com/xxgail/LeetCode-Go/String"
)

func main() {
	//A := []int{12, -4, 16, -5, 9, -3, 3, 8, 0}
	//res := Array.CanThreePartsEqualSum(A)
	//fmt.Println(res)

	//str1 := "ABABAB"
	//str2 := "ABAB"
	//res := String.GocOfStrings(str1, str2)

	//nums := []int{1, 2, 1, 1}
	//res := Array.MajorityElement(nums)
	//fmt.Println(res)
	//[10,9,2,5,3,7,101,18]
	//[4,10,4,3,8,9]
	//nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
	//res := DynamicProgramming.LengthOfLIS(nums)
	//s := "catsandog"
	//wordDict := []string{"cats","dog","sand","and","cat"}
	//res := DynamicProgramming.WordBreak(s,wordDict)
	//res := Backtracking.GenerateParenthesis(3)
	//one := &LinkedList.ListNode{
	//	Val: 1,
	//	Next: &LinkedList.ListNode{
	//		Val: 3,
	//		Next: &LinkedList.ListNode{
	//			Val: 4,
	//		},
	//	},
	//}
	//two := &LinkedList.ListNode{
	//	Val: 1,
	//	Next: &LinkedList.ListNode{
	//		Val: 4,
	//		Next: &LinkedList.ListNode{
	//			Val: 5,
	//		},
	//	},
	//}
	//three := &LinkedList.ListNode{
	//	Val: 2,
	//	Next: &LinkedList.ListNode{
	//		Val: 6,
	//	},
	//}
	//lists := []*LinkedList.ListNode{one, two, three}
	//res := LinkedList.MergeKLists(lists)
	//fmt.Println(res)
	//nums := []int{1, 2, 10, 3, 3, 4, 1, 4}
	//res := BitManipulation.SingleNumbers(nums)
	//fmt.Println(res)
	//fmt.Println(strings.IndexByte("widuu",'u'))
	//days := []int{6, 8, 9, 18, 20, 21, 23, 25}
	//costs := []int{2, 10, 41}
	//
	//res := DynamicProgramming.MinCostTickets(days, costs)
	//fmt.Println(res)
	//var root = &TreeNode.TreeNode{
	//
	//}
	//root.Val = 1
	//root.Left = &TreeNode.TreeNode{
	//	Val: 2,
	//	Left: &TreeNode.TreeNode{
	//		Val: 5,
	//		Left: nil,
	//		Right: nil,
	//	},
	//	Right: &TreeNode.TreeNode{
	//		Val: 7,
	//		Left: nil,
	//		Right: nil,
	//	},
	//}
	//root.Right = &TreeNode.TreeNode{
	//	Val: 3,
	//	Left: &TreeNode.TreeNode{
	//		Val: 6,
	//		Left: nil,
	//		Right: nil,
	//	},
	//	Right: &TreeNode.TreeNode{
	//		Val: 8,
	//		Left: nil,
	//		Right: nil,
	//	},
	//}
	//res := TreeNode.LevelOrder(root)
	//fmt.Println(res)

	//matrix := [][]byte{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}
	//matrix = [][]byte{{'1'}}
	//res1 := DynamicProgramming.MaximalSquare(matrix)
	//fmt.Println(res1)

	fmt.Println(String.ValidPalindrome("abccda"))
}
